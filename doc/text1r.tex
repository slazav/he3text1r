\documentclass[a4paper]{article}

\usepackage{amssymb}
\usepackage{euscript}
\usepackage{graphicx}
\graphicspath{{pics/}}
\usepackage{color}
\usepackage{epsfig}
\usepackage{fullpage}
\usepackage{verbatim}

\begin{document}

\title{{\tt text1r} --- calculate 1D radial texture}
\date{\today}
\author{}
\maketitle

\def\sp{\sqrt{5}}
\def\st{\sqrt{3}}
\def\ddd#1#2{\frac{\partial #1}{\partial #2}}

This library calculates $^3$He-B texture in a 1D cylindrically
symmetric geometry. Code and ideas came from ROTA programs (by J.Kopu,
S.Autti, ...). Interfaces for C, F, F90, Matlab, and Octave languages
are available.

\section*{Energy terms}

Sum of following energies is minimized:

\def\bn{{\bf n}}
\def\bH{{\bf H}}
\def\divn{(\nabla\cdot\bn)}
\def\rotn{(\nabla\times\bn)}
\def\grn{\nabla\bn}

Gradient energy:
$$
F_{G}  = \lambda_{G1}\int_V
  \frac{\partial R_{\alpha i}}{\partial r_i}
  \frac{\partial R_{\alpha j}}{\partial r_j}
       + \lambda_{G2}\int_V
  \frac{\partial R_{\alpha j}}{\partial r_i}
  \frac{\partial R_{\alpha j}}{\partial r_i}
$$

Magnetic energy in a uniform field $H$ along $z$ axis:
$$
F_{DH} = - a \int_V (\bn\cdot\bH)^2 = -a H^2 \int_V \sin^2\beta_N
$$

Spin-orbit energy for arbitrary distribution of precessing magnetization $\Psi$:
$$
F = \chi \frac{\Omega^2_B}{\gamma^2} \int_V  \Psi^2 \sin^2\beta_N
$$

Superflow energy for arbitrary distribution of counterflow ${\bf v_s-v_n}$:
$$
F_{HV} = - \lambda_{HV} \int_V [\bH \cdot R \cdot ({\bf v_s-v_n})]^2
$$

Vortex energy for arbitrary distribution of vortex density $\Omega_v$
and polarization ${\bf l_v}$:
$$
F = \frac15\ \frac{\lambda}{\Omega} \int_V  \Omega_v [\bH \cdot R \cdot {\bf l_v}]^2
$$

Surface energy:
\begin{eqnarray*}
F_{SH} &=& -d
  \int_S [{\bf H} \cdot R \cdot {\bf s} ]^2\ d^2r\\
F_{SG} &=& -\lambda_{SG}
  \int_S s_j R_{\alpha j}
    \frac{\partial R_{\alpha i}}{\partial r_i}\ d^2r\\
\end{eqnarray*}

Dipole energy is assumed to be constant, order parameter angle $\theta$
is fixed at $\cos^{-1}(-1/4)$.

\eject
\section*{Usage}

\subsection*{General}
To keep parameters and results we use a global data structure with following fields:

\begin{verbatim}
n     -- number of points
rr()  -- r grid [cm]
an()  -- azimuthal angle of n vector [deg]
bn()  -- polar angle of n vector [deg]
R     -- Cell radius [cm]
H     -- Magnetic field [G]

a     -- Textural dipole-field parameter a [erg/(cm3 G2)]
lg1   -- Textural parameter lambda_g1 [erg/cm]
lg2   -- Textural parameter lambda_g2 [erg/cm]
lhv   -- Textural parameter lambda_HV [erg/(cm3 G2) 1/(cm/s)2]
lsg   -- Textural parameter lambda_SG [???]
ld    -- Textural parameter lambda_D [erg/cm3]
lo    -- Textural parameter lambda/omega [s/rad]
d     -- Textural surface parameter d [erg/(cm2 G2)]

vr(), vz(), vf()  -- velocity profile
lr(), lz(), lf()  -- vortex polarization
w()    -- vortex dencity
apsi() -- magnon wavefunction amplitude
\end{verbatim}

Following functions are provided to calculate texture:
\begin{itemize}

\item {\bf text1r\_init(ttc, p, nu0, r, n, itype)} -- Initialize data
structure. Textural parameters are set according to temperature {\tt
ttc} (T/Tc) and pressure {\tt p} (bar) using {\tt libhe3} library.
$\lambda/Omega$ parameter is set to zero. Magnetic field is set from
{\tt nu0} Larmor frequency. Vortex and counterflow distributions are set
to zero. Initial distributions for $\alpha_N$ and $\beta_N$ are set
according to itype parameter: 0 means usual flare-out texture, 1 means
texture with 90-degree peak, 2 and more means even larger rotation of
{\bf n} vector. Parameters can be changed manually before minimization.

\item {\bf text1r\_set\_vortex\_cluster(dat, omega, omega\_v)} -- Set
counterflow and vortex profiles for central vortex cluster. Here {\tt
omega} is a rotation velocity of the container and {\tt omega\_v} is
rotation velocity of the cluster.

\item {\bf text1r\_set\_vortex\_uniform(dat, omega, omega\_v)} -- Set
counterflow and vortex profiles for uniform vortex cluster. Here
{\tt omega} is a rotation velocity of the container and {\tt omega\_v}
is rotation velocity of the cluster.

\item {\bf text1r\_set\_vortex\_twisted(dat, omega, kr)} -- Set
counterflow and vortex profiles for twisted vortex cluster.

\item {\bf text1r\_minimize(msglev)} -- Vary $\alpha_N$ and $\beta_N$
to find energy minimum. Parameter {\tt msglev} is used to control verbosity
level. To turn off all messages use -3.

\item {\bf text1r\_print(filename)} -- Print all data to a file.

\end{itemize}

\eject
\subsection*{Fortran}

Examples of Fortran 77 and Fortran 90 programs can be found in
{\tt examples} folder.

Simple usage:
\begin{verbatim}
  include '../text1r.fh'
  call text1r_init(ttc, p, nu0, r, n, itype)
  text_lo=5D0;
  call text1r_set_vortex_cluster(omega, omega_v);
  call text1r_minimize(msglev)
  call text1r_print('result.dat')
\end{verbatim}

Data is arranged as a common block {\tt text1r\_pars} with
fields {\tt text\_n, text\_rr, text\_an} etc.

\subsection*{C}
Example of C program can be found in {\tt examples} folder.

Simple usage:
\begin{verbatim}
  text1r_init_(&ttc, &p, &nu0, &r, &n, &itype);
  text1r_pars_.lo=5;
  text1r_set_vortex_cluster_(&omega, &omega_v);
  text1r_minimize_(&msglev);
  text1r_print_(fname, strlen(fname));
\end{verbatim}

You should include {\tt text1r.h} header file. Data is arranged as a
global structure {\tt text1r\_pars\_} with fields {\tt n, rr, an} etc. Usual
way of calling Fortran functions from a C program is used.

\subsection*{Matlab/Octave}
{\tt MEX}-files for Matlab and Octave can be build in {\tt matlab} folder.
Example of matlab script can be found in {\tt examples} folder.

Simple usage:
\begin{verbatim}
  dat = text1r_init(ttc, p, nu0, r, n, itype);
  dat = text1r_set_vortex_cluster(dat, omega, omega_v);
  dat.lo = 5;
  dat = text1r_minimize(dat, msglev);
\end{verbatim}

\begin{itemize}
\item additional {\tt dat} parameter is used to keep all texture data. It
is a matlab structure with fields {\tt n, rr, an} etc.

\item {\tt n} and {\tt itype} parameters in {\tt text1r\_init} can be omitted.
Default values: {\tt MAXN} and 0.

\item {\tt msglev} parameter in {text1r\_minimize} can be omitted.
Default value is -3/

\end{itemize}


\section*{Restrictions and TODO list}

\begin{itemize}

\item Maximal number of points is hardcoded into the library. You can
increase it by changing MAXN parameter in {\tt make\_inc} script and
recompiling everything.

\item Minimization of energy as a function $\alpha_N$ and $\beta_N$
parameters is not stable near $\beta_N=0$ (because $\alpha_N$ is not
defined there). This causes problems at high temperature, or high cell
radius, or high magnetic field (large $\xi_H$ limit). TODO: use
$n_x/(1+n_z)$ and $n_y/(1+n_z)$ as minimization parameters.

\item TODO: include dipolar energy, vary also $\theta$ angle (or
something like $n_i/\cos\theta$).

\item TODO: Use $\beta_M$ instead of $\Psi$.

\item TODO: Include eigenvalue solver for magnon wave function,
include non-uniform magnetic field...

\end{itemize}

\eject
\section*{Technical details}

\subsection*{Program structure}

\begin{itemize}
\item {\tt esurf} and {\tt ebulk} subroutines calculate surface and
bulk energy and its derivatives as a function of texture ($\alpha$ and
$\beta$) and texture gradients ($\partial\alpha/\partial r$,
$\partial\beta/\partial r$ etc.). Texture can be represented in various
forms ($\alpha, \beta$, or $\bf n$, or $R_{ij}$).

\item {\tt egrad} subroutine calculates total energy as integral of bulk energy over volume
plus integral of surface energy over surface and its derivatives as a
function of texture and texture gradients at the whole grid.

\item {\tt mfunc} is a wrapper for {\tt egrad}. Texture is represented
as 1-d array suitable for minimization (see below).

\item {\tt x2text} and {text2x} subroutines convert two representations of the texture.

\item {\tt minimize} subroutine does minimization.
\end{itemize}


\subsection*{Texture representation for minimization}

We don't want to minimize directly $F(n_r, n_z, n_f)$ because additional
condition $n_i n_i = 1$ should be taken into account. We also don't want
to minimize $F(\alpha, \beta$) because if $\beta=0$ then $\alpha$
is not defined.

One possibility is to use a projection of the $\bf n$ sphere into a plane
$z=0$ from a $z=-1, r=0$ point:

$$
u=\frac{n_r}{1+n_z}, \qquad  v=\frac{n_f}{1+n_z}.
$$

Inverse transformation is
$$
n_z = \frac{1-u^2-v^2}{1+u^2+v^2},\qquad
n_r = \frac{2u}{1+u^2+v^2},\qquad
n_f = \frac{2v}{1+u^2+v^2},\qquad
$$

We also need
$$
\ddd{E}{u} = \ddd{E}{\alpha}\ddd{a}{u} + \ddd{E}{\beta}\ddd{b}{u}
$$
$$
\ddd{E}{v} = \ddd{E}{\alpha}\ddd{a}{v} + \ddd{E}{\beta}\ddd{b}{v}
$$

We don't want to minimize $r=0$ point where $n_z=1$ because of cylindrical symmetry.
\end{document}

